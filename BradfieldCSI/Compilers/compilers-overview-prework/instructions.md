---
title: Overview of Compilers and Interpreters
---

<section>

## Reading {-}

Begin by reading the following sections of _Crafting Interpreters_:

* [Why Learn This Stuff?](https://www.craftinginterpreters.com/introduction.html#why-learn-this-stuff)
* [A Map of the Territory](https://www.craftinginterpreters.com/a-map-of-the-territory.html)

## Exercise {-}

Next, complete the implementation challenges in the included exercise files:

**Part 1: Evaluating Expressions**

The first part is to write a function that evaluates an arbitrary expression (such as `1 + 2 - 3 * 4`), where the expression is given in the form of an "abstract syntax tree" (AST) generated by the [`parser` package](https://pkg.go.dev/go/parser). The actual AST types, together with some useful helper functions, are defined in the [`ast` package](https://pkg.go.dev/go/ast).

You can assume that the expression (before parsing) only contained integer literals, basic arithmetic operations, and parentheses.

**Part 2: Refactoring**

The second part is to write a function that refactors Go files by sorting all function definitions in alphabetical order. Although reordering functions is a relatively simple operation in the grand scheme of things, the goal of this part is to demonstrate the benefit of working with code in a structured format (rather than raw text).

Note that Go's built-in `ast` library wasn't designed with code generation in mind. For example, see [#20744](https://github.com/golang/go/issues/20744). Instead, we recommend the third-party [`dst` library](https://github.com/dave/dst).

After finishing this part, you may want to consider:

* Are there other useful refactoring operations you might be interested in implementing (e.g. renaming variables in a scope-aware way, adding or reordering method parameters)?
* Do you have any ideas how you might implement a tool such as [gofmt](https://pkg.go.dev/cmd/gofmt)?

**Part 3: Bytecode Compilation**

Given a simple Go function `func f(x, y byte) byte` as input, can you compile it into bytecode that runs on a virtual machine (similar to the one you implemented in _Introduction to Computer Systems_)?

You can find more details about this part in the README included with the exercise files.